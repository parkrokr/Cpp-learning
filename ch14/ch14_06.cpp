// 예외처리의 위험성과 단점


//예외처리를 하다보면 메모리처리가 안되어서 메모리 누수가 발생할 수 있음
//스마트 포인터 사용

//소멸자 안에서 예외를 못던지게 되어있음(런타임 에러)

//예외 처리는 내부적으로 뭔가 비교를 하고 스택을 왔다갔다 하는듯 추가적인 연산이 필요하기 때문에
//for문 안에 try-catch 문을 넣는것 같은 빈번하게 예외처리르 하면 효율성이 많이 떨어짐
//가장 많이 사용하는 loop 에 try-catch 를 넣으면 느려짐
//최근엔 zero cost exception 이 나오고 있지만 아직은 페널티,runtime cost 가 있다고 함

//가급적 예외는 바깥쪽, main() 바로 안에

//모든 오류를 예외 처리로 잡으려고 하면 안됨
//정상적으로 작동해야 하는건 정상적으로 작동 하도록 if 문으로 걸러서 사용하는것이 좋음
//예제 초반의 사용자 입력 같은 경우 정상 범위의 값을 입력하도록 유도하는것이 좋음

//네트워크 서버, 분산처리, 병렬처리, 하드웨어 관련 작업, 하드디스크에 쓰기나 읽기를 할때
//예기치 못한 일이 있을 수 있기 때문에 다른 방법으로, 논리적으로 대비를 하기 힘든 경우
//예외 처리를 사용하기 좋음
//서버프로그래밍에서도 예외처리를 써야 하는지는 오래된 논란거리라고 함

//써야 할지 안할지는 실무에서 다듬어 나가야 함

#include <iostream>
#include <memory>

using namespace std;

class A
{
public:
	~A()
	{
		//소멸자 안에서 throw 하는건 금기시 되는 행동!
		//컴파일도 안됨(소멸자에선 예외를 못던지게 되어있음)
		//소멸자는 메모리를 지우고 정리하는 것인데 정상적으로 예외를 던질 수 있는 상태가 아니라고 보는것
		throw "error";
	}
};


int main()
{
	try
	{
		//정상적으로 작동을 하면 메모리를 반납하지만 예외가 발생한다면
		//delete 가 실행되지 못하고 바로 catch 로 넘어감
		//하지만 catch 에서 지역변수 포인터 i 에 접근할 방법이 없고 메모리 누수가 발생할 수 있음
		//이를 방지 하기 위한 스마트 포인터 ( include <memory> )

		int* i = new int[1000000];

		unique_ptr<int> up_i(i); //스마트 포인터, i를 여기에 넣으면 밑에서 delete 가 필요없음
		//영역을 벗어나면 유니크 포인터가 알아서 메모리를 지워줌
		//밑에서 throw 해서 날라갈때도 유니크 포인터가 알아서 지워줌
		//실전에선 많이 사용함


		//do something whith i
		throw "error";

		//delete[] i;	//unique_ptr<int> up_i(i); 덕분에 필요없음


	}
	catch(...)
	{
		cout << "Catch" << endl;
	}


	//소멸자에선 예외를 못던지게 되어있음
	try
	{
		//A a;
	}
	catch (...)
	{
		cout << "catch" << endl;
	}

	return 0;
}